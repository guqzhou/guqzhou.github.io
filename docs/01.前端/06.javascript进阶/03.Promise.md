## Promise
### 回调地狱
多层回调函数相互嵌套就形成了回调地狱
```js
setTimeout(() => {
    console.log('1s后执行')
    setTimeout(() => {
        console.log('2s后执行')
        setTimeout(() => {
            console.log('3s后执行')
        },3000)
    },2000)
},1000)
```
缺点：  
1. 代码冗余，难以维护
2. 大量的相互嵌套，代码可读性差

### 概念
#### 1. Promise是一个构造函数
* 我们可以创建Promise实例，const p = new Promise()
* new出来的实例对象代表异步操作
#### 2. Promise.prototype上包含一个.then()方法
* 每一次new出来的实例对象都可以通过原型链的方式访问到.then()方法
#### 3.then()方法用来预先指定成功和失败的回调函数
* p.then(成功的回调函数，失败的回调函数)
* p.then(res =>{}, err => {})
* 成功的回调函数必传的，失败的回调可选的

> 总结：promise是一个构造函数，因此我们可以用new关键字去创建它的实例对象，new出来的实例对象就代表异步操作，而且它的原型对象上包含一个.then方法,我们就可以通过new出来的实例对象去调用实例方法。预先去指定成功和失败的函数。


#### .then() 方法的特性
如果上一个.then()方法中返回一个promise实例对象，则可以通过.then()方法进行链式调用解决回调地狱的问题  
我们通过.then()的方法指定成功后的回调函数，但我们拿到成功后的回调函数后再返回一个新的promise()对象，用.then()方法指定成功回调函数，拿到第成功后的回调函数的返回值后再返回一个promise实例，用.then()的链式调用方法就能解决回调地狱的问题
all、 race并发请求

### async/await 注意是项
在async方法中，第一个await之前的代码回同步执行，await之后的代码会异步执行
```js
console.log('A')
async function getData () {
    console.log('B')
    const p = await new Promise()
    console.log('C')
    console.log('D')
}
getData()
console.log('E')

// 执行结果 A B E C D
```
