## EventLoop
javascript是单线程语言，同一时间只能做一件事情，单线程的语言就会出现程序假死的情景
### 同步和异步任务
为了防止耗时任务导致程序假死问题，js把待执行的任务分为同步和异步
#### 同步任务
* 非耗时任务，在主线程上排队执行的
* 只有前一个任务执行完毕，才能执行后一个任务
#### 异步任务
* 又叫耗时任务，异步任务由javascript委托给宿主环境执行的
* 当异步任务执行完后，会通知javascript主线程执行异步任务的回调函数

#### 同步任务异步任务的执行过程
* 同步任务是由js主线程按次序执行的
* 继续往下执行发现这个任务是异步任务，把异步任务委托给宿主环境执行
* 已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行
* javascript主线被清空后，会读取任务队列中的回调函数，次序执行

> 总结：js主线程会按照执行栈按顺序执行所有的任务，发现同步任务的时候js主线程自己执行它，发现它是一个异步任务就会委托给宿主环境去执行，js主线程就可以执行一些其他的非耗时任务，最后我们发现栈里面的任务都被执行完了以后，此时他会从任务队列里面按顺序把对应的回调函数取出来，然后再放到栈里面去执行

#### 异步任务
##### 宏任务
* 异步的ajax请求
* setTimeOut
* 文件操作
* 其他宏任务
##### 微任务
* promise.then()、catch()、finally()
* process.nextTick()
* 其它微任务
执行顺序：每一个宏任务执行完成以后，都会检查是否存在待执行的微任务，如果有，执行所有的微任务后，再继续执行下一个宏任务


```js
console.log('1')
setTimeout(() => {
    new Promise((resolve) => {
        console.log(2)
        resolve()
    }).then(() => {
        console.log(3)
    })
})

new Promise((resolve) => {
    console.log(4)
    resolve()
}).then(() => {
    console.log(5)
})

setTimeout(() => {
    new Promise((resolve) => {
        console.log(6)
        resolve()
    }).then(() => {
        console.log(7)
    })
})

// 1 4 5 2 3 6 7
```
